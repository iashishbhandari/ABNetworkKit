## Usage

### Making a Request

A sample request enumeration confirming the `RequestProtocol`

```swift
import ABNetworkKit

enum SampleRequest: RequestProtocol {

    case fetchSampleData

    var actionType: RequestAction {
        return .standard
    }

    var headers: [String : String]? {
        return ["content-type" : "application/json"]
    }

    var method: HTTPMethod {
        return .get
    }

    var parameters: RequestParams {
        return .url(nil)
    }

    var path: String {
        return "/location"
    }

    var responseType: ResponseType {
        return .json
    }
}

```

### Making a Operation

A sample operation enumeration confirming the `OperationProtocol`

```swift

class SampleOperation: OperationProtocol {

    var sessionTask: URLSessionTask?

    typealias Output = NetworkResponse

    var request: RequestProtocol

    init(_ request: RequestProtocol) {
        self.request = request
    }

    func cancel() {
        sessionTask?.cancel()
    }

    func execute(in dispatcher: DispatcherProtocol, 
                    _ completion: @escaping (NetworkResponse) -> Void) {
        
        do {
            sessionTask = try dispatcher.execute(request: request, 
                                                    completion: { (response) in
                completion(response)
            })

        } catch (let exception) {
            completion(NetworkResponse.error(exception, nil))
        }
    }
}

```

### Response Handling

The `NetworkResponse` handler for converting HTTP Response to corresponding `ResponseType`

```swift

enum NetworkResponse {

    case binary(_: Data?, _: HTTPURLResponse?)

    case error(_: Error?, _: HTTPURLResponse?)

    case json(_: Any?, _: HTTPURLResponse?)
}

```


### Session Delegate

By default, an ABNetworkKit `NetworkServices` instance creates a SessionDelegate object to handle all the various types of delegate callbacks that are generated by the underlying URLSession.

The following is a short example of how to use the `taskWillPerformHTTPRedirection` to avoid following redirects to any apple.com domains.

```swift

let services = ABNetworkKit.NetworkServices(configuration:.default, 
                                                delegate: OperationQueue())

services.taskWillPerformHTTPRedirection = { session, task, response, request in
    var finalRequest = request
    if let originalRequest = task.originalRequest,
        let urlString = originalRequest.url?.urlString,
        urlString.contains("apple.com") {
            finalRequest = originalRequest
    }
    return finalRequest
}

```

### Authentication

Authentication is handled on the system framework level by [`URLAuthenticationChallenge`](https://developer.apple.com/reference/foundation/urlauthenticationchallenge).

### NetworkSecurityPolicy

The `evaluateServerTrust` method on a `Request` will automatically provide a `URLCredential` to a `URLAuthenticationChallenge` when appropriate based on user defined `SSLPinningMode` policy:

```swift

internal enum SSLPinningMode {

    case certificate

    case none
}

```

> It is important to note that when using a `URLCredential` for authentication, the underlying `URLSession` will actually end up making two requests if a challenge is issued by the server. The first request will not include the credential which "may" trigger a challenge from the server. The challenge is then received by ABNetworkKit, the credential is appended and the request is retried by the underlying `URLSession`.


